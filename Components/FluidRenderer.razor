@inject IJSRuntime JSRuntime;

<canvas @ref="htmlCanvas" width="800" height="600"></canvas>


@code {

    public ElementReference htmlCanvas;
    public IJSObjectReference? context2D;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context2D = await JSRuntime.InvokeAsync<IJSObjectReference>("getCanvasContext2D", htmlCanvas);
            await context2D.InvokeVoidAsync("setFillStyle", "black");
            await context2D.InvokeVoidAsync("fillRect", 0, 0, 800, 600);
        }
    }
    public void UpdateScene()
    {
        // This method can be used to trigger a re-render of the FluidRenderer component
        // when the simulation state changes.
        StateHasChanged();
    }
    public async Task rgbColors(float red, float green, float blue)
    {
        // TODO: Check if context2D is null before invoking methods
        await context2D.InvokeVoidAsync("setFillStyle", $"rgb({red * 255}, {green * 255}, {blue * 255})");
    }

    public float[] scientificColors(float value, float minValue, float maxValue)
    {
        value = Math.Clamp(value, minValue, maxValue - 0.0001f);
        float range = maxValue - minValue;
        float normalizedValue = range == 0.0f ? 0.5f : (value - minValue) / range;
        float segmentSize = 0.25f; // 4 segments
        int segmentIndex = (int)(normalizedValue / segmentSize);
        float segmentOffset = (normalizedValue - segmentIndex * segmentSize) / segmentSize;

        float red, green, blue;
        switch (segmentIndex)
        {
            case 0: red = 0.0f; green = segmentOffset; blue = 1.0f; break;
            case 1: red = 0.0f; green = 1.0f; blue = 1.0f - segmentOffset; break;
            case 2: red = segmentOffset; green = 1.0f; blue = 0.0f; break;
            case 3: red = 1.0f; green = 1.0f - segmentOffset; blue = 0.0f; break;
            default: red = green = blue = 1.0f; break; // Fallback color
        }

        return [255.0f*red, 255.0f*green, 255.0f*blue, 255]; // Add alpha channel
    }

    public async Task draw() 
    {
        await context2D.InvokeVoidAsync("clearRect", 0, 0, 800, 600);
        await context2D.InvokeVoidAsync("setFillStyle", "#FF0000");
    }
}

	@* // draw -------------------------------------------------------

	function setColor(r,g,b) {
		c.fillStyle = `rgb(
			${Math.floor(255*r)},
			${Math.floor(255*g)},
			${Math.floor(255*b)})`
		c.strokeStyle = `rgb(
			${Math.floor(255*r)},
			${Math.floor(255*g)},
			${Math.floor(255*b)})`
	}

	function draw() 
	{
		c.clearRect(0, 0, canvas.width, canvas.height);

		c.fillStyle = "#FF0000";
		f = scene.fluid;
		n = f.numY;

		var cellScale = 1.1;

		var h = f.h;

		minP = f.p[0];
		maxP = f.p[0];
using System.Formats.Tar;
#line default
#line hidden
inP = Math.min(minP, f.p[i]);
			maxP = Math.max(maxP, f.p[i]);
		}uusing System.Reflection.Metadata;
#line default
#line hidden
e hidden
 = c.getImageData(0,0, canvas.width, canvas.height)

		var color = [255, 255, 255, 255]

		for (var i = 0; i < f.numX; i++) {
			for (var j = 0; j < f.numY; j++) {

				if (scene.showPressure) {
					var p = f.p[i*n + j];
					var s = f.m[i*n + j];
					color = getSciColor(p, minP, maxP);
					if (scene.showSmoke) {
						color[0] = Math.max(0.0, color[0] - 255*s);
						color[1] = Math.max(0.0, color[1] - 255*s);
						color[2] = Math.max(0.0, color[2] - 255*s);
					}
				}
				else if (scene.showSmoke) {
					var s = f.m[i*n + j];
					color[0] = 255*s;
					color[1] = 255*s;
					color[2] = 255*s;
					if (scene.sceneNr == 2)
						color = getSciColor(s, 0.0, 1.0);
				}
				else if (f.s[i*n + j] == 0.0) {
					color[0] = 0;
					color[1] = 0;
					color[2] = 0;
				}

				var x = Math.floor(cX(i * h));
				var y = Math.floor(cY((j+1) * h));
				var cx = Math.floor(cScale * cellScale * h) + 1;
				var cy = Math.floor(cScale * cellScale * h) + 1;

				r = color[0];
				g = color[1];
				b = color[2];

				for (var yi = y; yi < y + cy; yi++) {
					var p = 4 * (yi * canvas.width + x)

					for (var xi = 0; xi < cx; xi++) {
						id.data[p++] = r;
						id.data[p++] = g;
						id.data[p++] = b;
						id.data[p++] = 255;
					}
				}
			}
		}

		c.putImageData(id, 0, 0);

		if (scene.showVelocities) {

			c.strokeStyle = "#000000";	
			scale = 0.02;	

			for (var i = 0; i < f.numX; i++) {
				for (var j = 0; j < f.numY; j++) {

					var u = f.u[i*n + j];
					var v = f.v[i*n + j];

					c.beginPath();

					x0 = cX(i * h);
					x1 = cX(i * h + u * scale);
					y = cY((j + 0.5) * h );

					c.moveTo(x0, y);
					c.lineTo(x1, y);
					c.stroke();

					x = cX((i + 0.5) * h);
					y0 = cY(j * h );
					y1 = cY(j * h + v * scale)

					c.beginPath();
					c.moveTo(x, y0);
					c.lineTo(x, y1);
					c.stroke();

				}
			}
		}

		if (scene.showStreamlines) {

			var segLen = f.h * 0.2;
			var numSegs = 15;

			c.strokeStyle = "#000000";

			for (var i = 1; i < f.numX - 1; i += 5) {
				for (var j = 1; j < f.numY - 1; j += 5) {

					var x = (i + 0.5) * f.h;
					var y = (j + 0.5) * f.h;

					c.beginPath();
					c.moveTo(cX(x), cY(y));

					for (var n = 0; n < numSegs; n++) {
						var u = f.sampleField(x, y, U_FIELD);
						var v = f.sampleField(x, y, V_FIELD);
						l = Math.sqrt(u*u + v*v);
						// x += u/l * segLen;
						// y += v/l * segLen;
						x += u * 0.01;
						y += v * 0.01;
						if (x > f.numX * f.h)
							break;

						c.lineTo(cX(x), cY(y));
					}
					c.stroke();
				}
			}
		}

		if (scene.showObstacle) {

			c.strokeW
			r = scene.obstacleRadius + f.h;
			if (scene.showPressure)
				c.fillStyle = "#000000";
			else
				c.fillStyle = "#DDDDDD";
			c.beginPath();	
			c.arc(
				cX(scene.obstacleX), cY(scene.obstacleY), cScale * r, 0.0, 2.0 * Math.PI); 
			c.closePath();
			c.fill();

			c.lineWidth = 3.0;
			c.strokeStyle = "#000000";
			c.beginPath();	
			c.arc(
				cX(scene.obstacleX), cY(scene.obstacleY), cScale * r, 0.0, 2.0 * Math.PI); 
			c.closePath();
			c.stroke();
			c.lineWidth = 1.0;
		}

		if (scene.showPressure) {
			var s = "pressure: " + minP.toFixed(0) + " - " + maxP.toFixed(0) + " N/m";
			c.fillStyle ="#000000";
			c.font = "16px Arial";
			c.fillText(s, 10, 35);
		}
	}

	function setObstacle(x, y, reset) {

		var vx = 0.0;
		var vy = 0.0;

		if (!reset) {
			vx = (x - scene.obstacleX) / scene.dt;
			vy = (y - scene.obstacleY) / scene.dt;
		}

		scene.obstacleX = x;
		scene.obstacleY = y;
		var r = scene.obstacleRadius;
		var f = scene.fluid;
		var n = f.numY;
		var cd = Math.sqrt(2) * f.h;

		for (var i = 1; i < f.numX-2; i++) {
			for (var j = 1; j < f.numY-2; j++) {

				f.s[i*n + j] = 1.0;

				dx = (i + 0.5) * f.h - x;
				dy = (j + 0.5) * f.h - y;

				if (dx * dx + dy * dy < r * r) {
					f.s[i*n + j] = 0.0;
					if (scene.sceneNr == 2) 
						f.m[i*n + j] = 0.5 + 0.5 * Math.sin(0.1 * scene.frameNr)
					else 
						f.m[i*n + j] = 1.0;
					f.u[i*n + j] = vx;
					f.u[(i+1)*n + j] = vx;
					f.v[i*n + j] = vy;
					f.v[i*n + j+1] = vy;
				}
			}
		}
		
		scene.showObstacle = true;
	}

	// interaction -------------------------------------------------------

	var mouseDown = false;

	function startDrag(x, y) {
		let bounds = canvas.getBoundingClientRect();

		let mx = x - bounds.left - canvas.clientLeft;
		let my = y - bounds.top - canvas.clientTop;
		mouseDown = true;

		x = mx / cScale;
		y = (canvas.height - my) / cScale;

		setObstacle(x,y, true);
	}

	function drag(x, y) {
		if (mouseDown) {
			let bounds = canvas.getBoundingClientRect();
			let mx = x - bounds.left - canvas.clientLeft;
			let my = y - bounds.top - canvas.clientTop;
			x = mx / cScale;
			y = (canvas.height - my) / cScale;
			setObstacle(x,y, false);
		}
	}

	function endDrag() {
		mouseDown = false;
	}

	canvas.addEventListener('mousedown', event => {
		startDrag(event.x, event.y);
	});

	canvas.addEventListener('mouseup', event => {
		endDrag();
	});

	canvas.addEventListener('mousemove', event => {
		drag(event.x, event.y);
	});

	canvas.addEventListener('touchstart', event => {
		startDrag(event.touches[0].clientX, event.touches[0].clientY)
	});

	canvas.addEventListener('touchend', event => {
		endDrag()
	});

	canvas.addEventListener('touchmove', event => {
		event.preventDefault();
		event.stopImmediatePropagation();
		drag(event.touches[0].clientX, event.touches[0].clientY)
	}, { passive: false});


	document.addEventListener('keydown', event => {
		switch(event.key) {
			case 'p': scene.paused = !scene.paused; break;
			case 'm': scene.paused = false; simulate(); scene.paused = true; break;
		}
	});

	function toggleStart()
	{
		var button = document.getElementById('startButton');
		if (scene.paused)
			button.innerHTML = "Stop";
		else
			button.innerHTML = "Start";
		scene.paused = !scene.paused;
	} *@